### 一、深度图解剖析Elasticsearch并发冲突问题
>电商场景：  
`程序工作流程：①读取商品信息(包括商品库存)；②用户下单；③更新商品信息(将库存减一)。`


>假设程序为多线程，可并发执行上述3步骤。
>- 有一款牙膏，库存100件，同时有两位用户读取牙膏数据分别购买，此时两个线程并发服务于两个人，同时在进行商品库存数据修改。  
这两个线程总有一个线程是先到的，假设为A，此时线程A会将牙膏库存设置为99件，然后线程B再次将牙膏库存设置为99件，此时结果就错了。  
正确情况，期望线程A将库存-1，设置为99件；然后线程B接着将库存-1，设置为98件，最后设置到ES中。  
>>上面说的流程和过程，就是ES中的并发冲突问题，会导致数据不准确。  
>>- ①有些场景下，不关心数据准确性。eg.若只是简单将数据写入ES，无论数据如何，都可以；甚至有些情况，算错了也可以。
>>- ②当并发操作ES的线程越多，或并发请求越多，或读取一份数据供用户查询、操作时间越长，可能这段时间内数据在ES中已被修改，那我们拿到的就是旧数据，基于旧数据去操作，结果肯定错了。

![image](https://raw.githubusercontent.com/nanphonfy/note-images/master/bigdata-cookbook/elasticsearch/practice/06/concurrency_conflict.png)

- 普通ES操作流程：  
>①先get document，商品信息，显示到网页，同时在内存中缓存该document数据；  
②当网页发起购买，直接基于内存的数据，进行计算和操作；  
③将计算后的结果写回ES中。

### 二、深度图解剖析悲观锁与乐观锁两种并发控制方案
#### 1.悲观锁并发控制方案
>各种情况都上锁，上锁后只有一个线程可操作这一条数据。不同场景，上的锁不同：行级锁、表级锁、读锁、写锁。

#### 2.悲观锁与乐观锁
>- ①悲观锁优点：方便，直接加锁对应用程序透明、不需额外操作。  
>- 缺点：并发能力很低，同一时间只能有一条线程操作数据。  

>- ②乐观锁优点：并发能力很高，不给数据加锁，大量线程并发操作。
>- 缺点：麻烦，每次更新时都先比对版本号，再重新加载数据，再修改、写。整个过程可能重复好几次。

>线程B去判断当前数据的版本号：version=1，与es数据的版本号：version=2，是否相同。  
版本号不同，说明数据已经被其他人修改过，此时用户B不会去更新，而是重新从es中读取最新的数据版本——99件，再次减1，变为98件，再执行上述流程，就可写入。

![image](https://raw.githubusercontent.com/nanphonfy/note-images/master/bigdata-cookbook/elasticsearch/practice/06/pressimistic_lock.png)

![image](https://raw.githubusercontent.com/nanphonfy/note-images/master/bigdata-cookbook/elasticsearch/practice/06/optimistic_lock.png)

### 三、上机演练：基于_version进行乐观锁并发控制

#### 1.kibana
- 构造一条数据
```
http://localhost:5601/app/kibana

PUT /test_index/test_type/1
{
  "test_field": "test value"
}

{
  "_index": "test_index",
  "_type": "test_type",
  "_id": "1",
  "_version": 1,
  "result": "created",
  "_shards": {
    "total": 2,
    "successful": 1,
    "failed": 0
  },
  "created": true
}
```
- 模拟两个客户端，都获取到同一条数据

```
GET /test_index/test_type/1

{
  "_index": "test_index",
  "_type": "test_type",
  "_id": "1",
  "_version": 1,
  "found": true,
  "_source": {
    "test_field": "test value"
  }
}
```
- 其中一个客户端，先更新数据
>同时带上数据版本号，确保es中的数据版本号，跟客户端中的数据版本号是相同的，才能修改。
```
PUT /test_index/test_type/1?version=1 
{
  "test_field": "test client 1"
}

{
  "_index": "test_index",
  "_type": "test_type",
  "_id": "1",
  "_version": 2,
  "result": "updated",
  "_shards": {
    "total": 2,
    "successful": 1,
    "failed": 0
  },
  "created": false
}
```
- 另外一个客户端，尝试基于version=1的数据去修改，同样带上version版本号，进行乐观锁的并发控制
```
PUT /test_index/test_type/1?version=1 
{
  "test_field": "test client 2"
}

{
  "error": {
    "root_cause": [
      {
        "type": "version_conflict_engine_exception",
        "reason": "[test_type][1]: version conflict, current version [2] is different than the one provided [1]",
        "index_uuid": "y2nEh3rlTJu0N_zLKxsKxQ",
        "shard": "3",
        "index": "test_index"
      }
    ],
    "type": "version_conflict_engine_exception",
    "reason": "[test_type][1]: version conflict, current version [2] is different than the one provided [1]",
    "index_uuid": "y2nEh3rlTJu0N_zLKxsKxQ",
    "shard": "3",
    "index": "test_index"
  },
  "status": 409
}
```
- 在乐观锁成功阻止并发问题后，尝试正确的更新
>基于最新的数据和版本号进行修改，修改后，带上最新的版本号，可能这个步骤需要反复执行好几次才能成功，特别在多线程并发更新同一条数据很频繁的情况下。

PUT /test_index/test_type/7?version=2 
```
PUT /test_index/test_type/1?version=2
{
  "test_field": "test client 2"
}

{
  "_index": "test_index",
  "_type": "test_type",
  "_id": "1",
  "_version": 3,
  "result": "updated",
  "_shards": {
    "total": 2,
    "successful": 1,
    "failed": 0
  },
  "created": false
}
```

### 四、上机演练：基于external version进行乐观锁并发控制
#### 1.external version
>es提供了一个feature：可不用内部提供的_version版本号来进行并发控制，可以基于自己维护的版本号进行并发控制。eg.加入es的数据在mysql里也有一份，我们的应用系统本身也维护了一个版本号（无论是自己生成|程序控制）。
进行乐观锁并发控制时，可能并不想用es内部的_version来进行控制，而是用自己维护的version来进行控制。

`?version=1`  
`?version=1&version_type=external`

- version_type=external与前者区别
>唯一区别:  
_version——只有当提供的version与es中的_version一模一样时，才可进行修改，只要不一样，就报错；当version_type=external时，只有当提供的version比es中的_version大时，才能完成修改。  
>>es，_version=1，?version=1，才能更新成功;  
es，_version=1，?version>1&version_type=external，才能成功。

- 先构造数据
>