- 草稿
```SQL
B树索引最常见，存储逻辑不一样，位图索引用在数据仓库多点。
索引能指向表里面的数据
索引内部结构：根->分支->叶子。
索引建立在列上。

索引大于0，就指向B1。
索引列的值大于500则放在B2；
大于1000大于B3。

根节点第一次细分。
B1块存放0-500的索引。
如果索引列在0-200间，索引数据放在L1块里面；

叶子节点 索引列的值为0 的值 对应到物理硬盘R1位置。
数据库表所有数据行在索引上的值。

B树索引要特别理解。

create index ind1 on student(sno);

select *from user_indexes;

select *from user_ind_columns u
where u.index_name='IND1';

分析索引
索引块的数据可能被删除，有效数据少了。那么索引块会存在碎片，降低性功能。

create table t(c1 char(8));

begin
  for i in i..1300000 loop
     insert into t values(ltrim(tochar(i), '00000009'));
	 if mod(i,100)=0 then
	   commit;
	 end if;
   end loop;
/

--创建索引
create index ind_t on t(c1);

--分析索引
analyze index ind_t validate structure;

--查看索引使用率与碎片。默认最多只能插满90%
select name,pct_used from index_stats where name='IND_T';

--删除一部分数据
delete t where rownum < 1000000;
commit;

--oracle会自动分析索引
--查看索引使用率与碎片。默认最多只能插满90%
select name,pct_used from index_stats where name='IND_T';


--如果发现索引使用率过低
--重建索引
alter index ind_t rebuild;

--分析索引
analyze index ind_t validate structure;

--查看索引使用率与碎片。默认最多只能插满90%
select name,pct_used from index_stats where name='IND_T';

--唯一索引
create unique index ind_sno on student(sno);
--可以为null空值
空值可以有多个，它不违反unique index约束

select *from  user_indexes;

--创建组合索引
create index ind1 on 表（多个列）;
--在实际项目中，用户经常会发出多列条件的查询，可以建立组合索引

--【反向键索引】
建立索引的叶子节点，有的有很多条目，有的只有一两个
会使得整棵树不平衡。为了实现平衡放置
1001 1002 1003 1004 1005 ...
1001 2001 3001 4001 5001 ...
会使数据分布得更加均匀，使得将来查询速度更快。

--【位图索引】
--用0101来指明数据放哪里
select *from student;

create bitmap index ind2 on student(mail)

--【基于函数的索引】
select *from student where sname ='TOM';
对于某一列大小写不清楚
select *from student where upper(sname) ='TOM';
create index ind3 on student(upper(sname));

--以后用户再执行上面的命令 where upper(sname) ='TOM，则会非常快。

--创建分区表
create table employee1（code number,name varchar2(10)）
partition by range(code)(
  partition p1 values less than(1000),
  partition p2 values less than(2000),
  partition p3 values less than(maxvalue),
)

--局部分区索引
create index ind_empoyee1 on employee1（code) local;

--
select u.index_name,u.table_name,u.partitioned from user_indexes u;

--如何查看分区索引的详细信息
select *from user_ind_partitions;

--全局分区索引
create table employee2（code number,name varchar2(10)）
partition by range(code)(
  partition p1 values less than(1000),
  partition p2 values less than(2000),
  partition p3 values less than(maxvalue),
)

create index ind_empoyee1 on employee1（code) global partition by range(code)
(partition a1 values less than (1500),partition a2 values less than (maxvalue));


--全局非分区索引
create table employee3（code number,name varchar2(10)）
partition by range(code)(
  partition p1 values less than(1000),
  partition p2 values less than(2000),
  partition p3 values less than(maxvalue),
)

create index ind_empoyee1 on employee3（code) global;

--如何查看分区索引的详细信息______在这个视图查不到
select *from user_ind_partitions;
```
