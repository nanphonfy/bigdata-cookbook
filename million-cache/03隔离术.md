隔离：将系统或资源分割开，以防止发生故障后的滚雪球效应。
保证只有出问题的服务不可用，其他服务可用。
隔离手段：线程、进程、集群、机房、读写、快慢、动静、爬虫隔离等。
出问题时，考虑负载均衡路由、自动/手动切换分组、降级。

### 1.线程隔离
>主要指线程池隔离，把请求分类到不同线程池，不会将故障扩散到其他线程池。
eg.根据服务等级划分两个线程池，http请求->Tomcat单线程->核心业务队列->核心业务线程池->线程1（业务处理&生成响应）、线程2……线程n
http请求->Tomcat单线程->非核心业务队列->核心业务线程池->线程1（业务处理&生成响应）、线程2……线程n

### 2.进程隔离
>- ①初期，开发大而全的系统，某模块/功能出问题，可导致整个系统不可用；
>- ②部署多个实例，负载均衡路由转发（某模块导致OOM风险）；
>- ③将系统拆分为多个子系统实现 物理隔离（进程隔离）。

### 3.集群隔离
>随系统发展，单实例服务需要服务化，通过部署多个服务形成服务集群，提升系统容量。  
随调用方增多，当秒杀服务被刷会影响其他服务，为秒杀提供单独的服务集群（服务分组）  
>>商品服务（实例1、2）——分组1（商品详情页、购物车、订单服务）  
商品服务（实例1、2）——分组2（秒杀服务）

### 4.机房隔离
>系统可用性，多机房部署，机房各自有服务分组，本机房只调用本机房服务，不跨机房。  
>>机房发生问题（提升系统可用性）：  
①通过DNS/负载均衡->全部切到另一机房；  
②服务自动重试其他机房服务。

### 5.读写隔离 
>将读和写集群分离，读服务只从redis集群获取数据。  
>>①当主redis集群出现问题，从依然可用；
②从集群出问题，可对其他集群重试。

### 6.动静隔离
>eg.结算页：若JS/CSS等静态资源在此，因访问量太大，带宽撑满，可不用。  
一般将动态内容和静态资源分离，一般奖静态资源放在CDN（CDN->nginx）
